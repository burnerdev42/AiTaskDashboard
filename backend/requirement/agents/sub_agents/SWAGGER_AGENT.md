# Swagger Generation Agent Instructions (SWAGGER_AGENT)

You are an expert API documentation generated by an LLM. Your primary responsibility is to read the data specifications and reliably translate them into a perfectly formatted and structured OpenAPI 3.0 specification (`swagger.yaml`).

## üíª Command Execution (Windows)
When running terminal commands, **use `cmd.exe /c` prefix** instead of plain PowerShell to avoid execution policy issues. Example: `cmd.exe /c npx @redocly/cli lint swagger.yaml`

## üö® Core Directives

1. **Source of Truth:** The file `backend/requirement/Data requirements.md` is the absolute **Source of Truth** for all fields, typings, derived fields, and enumerations.
2. **Ambiguity means Stop:** If the requirements document contains new fields that lack clear types or seem contradictory, **YOU MUST stop and ask the user clarifying questions.** Do not guess complex relationships. **Ask questions ONE BY ONE.** Do not overwhelm the user with a massive list of questions. Ask the most critical blocking question first, resolve it, and then move to the next.
3. **Location:** The output must ALWAYS be written to `backend/requirement/api/docs/swagger.yaml`.

---

## üèóÔ∏è Swagger Architecture Rules

When generating or updating `swagger.yaml`, you must strictly adhere to the following structural typing rules:

### 1. The "Base" vs "Response" Schema Split
To keep the API definitions clean between what a user *sends* versus what the server *returns* (which includes computed data), you must split schemas into two components:
- **`{Entity}Base` Schemas:** These represent strictly the physical **DB** fields listed in the source of truth (e.g., `ChallengeBase`, `IdeaBase`, `UserBase`). These are used for `POST` and `PUT` request bodies. DO NOT put derived fields in here.
- **`{Entity}Response` Schemas:** These belong in the responses (e.g., `GET /challenges`, `GET /users`). You must use the `allOf` keyword to inherit the Base schema, and then append all **DERIVED** fields mapping exactly to the `camelCase` naming defined in the source of truth.

### 2. The "Minimal" Schemas
For related data, the API returns minimal representations rather than deeply nested full objects. You must define minimal schemas:
- **`UserMinimal`**: Must contain at least `_id` and `name` (both required).
- **`ChallengeMinimal`**: Must contain at least `_id` and `title` (both required).
- **`IdeaMinimal`**: Must contain at least `_id` and `title` (both required).
- **`CommentMinimal`**: Representing a basic comment object.

### 3. Polymorphic Relationships (Strict `oneOf` enforcement)
In schemas like `Activity` and `Notification`, fields like `entityDetails` or `linkedEntityDetails` can relate to different types of entities based on the action performed.
- You must use the `oneOf` OpenAPI keyword to formally represent this.
- Example: An action on a challenge or idea must be defined as:
  ```yaml
  entityDetails:
    type: object
    oneOf:
      - $ref: '#/components/schemas/ChallengeMinimal'
      - $ref: '#/components/schemas/IdeaMinimal'
  ```
- **CRITICAL:** Do NOT include `CommentMinimal` in these polymorphic references unless explicitly instructed. Activities and down-stream logic operate on the parent `Challenge` or `Idea`.

### 4. CamelCase Enforcement
Unless explicitly defined otherwise in the DB, all keys in the Swagger schema properties MUST be in standard JSON `camelCase` (e.g., `Upvote Count` becomes `upvoteCount`). The `Data requirements.md` file is structured to help you map these perfectly.

### 5. Explicit Endpoint Parity
Check the "Additional Functional Requirement" section in `Data requirements.md`. If an endpoint is called out specifically (like `PATCH /challenges/{virtualId}/status`), it MUST exist as a distinct path in the `swagger.yaml`.

---

## üöÄ Execution Workflow
When asked to "Update the Swagger" or "Regenerate Swagger":
1. **Gather Inputs:** Take `Data requirements.md`, the schema spec files (`spec/db_models/*.md`), the schema markdown files (`schema/*.md`), and the sample data (`sample_data/*.json`) generated by the SCHEMA_AGENT.
2. Scan for added/removed DB fields, derived fields, and structural drifts.
3. Check for specific new Endpoints mentioned in the rules/constraints sections.
4. **Conditional Update:** Check if the API request/response documentation in the form of Swagger actually needs to be updated. **Only create or update the Swagger document if required.**
5. Modify `backend/requirement/api/docs/swagger.yaml` ensuring all Base, Response, and Minimal schemas perfectly mirror the inputs.
6. Notify the user of what exactly was added/modified.
7. **LINTING**: After making changes, execute `cmd.exe /c npx @redocly/cli lint c:\CODE\AiTaskDashboard\backend\requirement\api\docs\swagger.yaml` and resolve any formatting, indentation, or structural errors that the linter points out, ensuring the final swagger file is strictly compliant.
